<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue</title>
    <url>/2020/04/17/vue/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="1-前端开发模式的发展"><a href="#1-前端开发模式的发展" class="headerlink" title="1.前端开发模式的发展"></a>1.前端开发模式的发展</h4><p>1.静态页面</p>
<p>　　最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容。</p>
<p>2.异步刷新，操作DOM</p>
<p>　　1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。</p>
<p>3.ajax盛行：</p>
<p>　　2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如jQuery就是典型代表。</p>
<p>4.MVVM，关注模型和视图</p>
<p>　　M：即Model，模型，包括数据和一些基本操作 </p>
<p>　　V：即View，视图，页面渲染结果 </p>
<p>　　VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） </p>
<p>　　在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 </p>
<p>　　而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： </p>
<p>　　　只要Model发生了改变，View上自然就会表现出来。 </p>
<p>　　　当用户修改了View，Model中的数据也会跟着改变。 </p>
<p>　　把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。</p>
<h4 id="2-认识Vue"><a href="#2-认识Vue" class="headerlink" title="2.认识Vue"></a>2.<strong>认识</strong>Vue</h4><p>　　是一套用于构建用户界面的<strong>渐进式框架</strong>(可以有选择性的使用该框架的一个或一些组件)。</p>
<p>　　前端框架三巨头:Vue.js,React.js,AngularJS,vue以其轻量易用著称</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>1.创建静态web工程</p>
<p>2.安装vue</p>
<p>　　官网下载<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a></p>
<p>　　公共的CDN(引用在线的vue.js)</p>
<!-- 开发环境版本，包含了用帮助的命令行警告 --> 

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<!-- 生产环境版本，优化了尺寸和速度 --> 

<script src="https://cdn.jsdelivr.net/npm/vue"></script> 

<p>　　npm安装(推荐)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#初始化</span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">#下载vue模块</span><br><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p>3.vue渲染</p>
<p>　　new Vue()来创建Vue实例</p>
<p>　　然后构造函数接收一个对象，对象中有一些属性： </p>
<p>　　　el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div </p>
<p>　　　data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 </p>
<p>　　　　name：这里指定了一个name属性 </p>
<p>　　页面中的 h2 元素中，通过的方式，来渲染刚刚定义的name属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;123<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            name:<span class="string">"刘洋"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.双向绑定</p>
<p>　　没有任何dom操作，这就是双向绑定的魅力。</p>
<p>　　输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。 </p>
<p>　　　input与num绑定，input的value值变化，影响到了data中的num值 </p>
<p>　　　页面  与数据num绑定，因此num值变化，引起了页面效果变化</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;的房子有&#123;&#123;num&#125;&#125;套</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            name:<span class="string">"刘洋"</span>,</span></span><br><span class="line">            num:10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.事件处理</p>
<p>　　这里用 v-on 指令绑定点击事件，而不是普通的 onclick ，然后直接操作num </p>
<p>​            普通onclick是无法直接操作num的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"num"</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"num++"</span>&gt;</span>点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;的房子有&#123;&#123;num&#125;&#125;个</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            name:<span class="string">"刘洋"</span>,</span></span><br><span class="line">            num:10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><p>1.创建</p>
<p>2.模板或元素</p>
<p>​        每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染；可以通过el属性来指定。</p>
<p>3.数据</p>
<p>　　当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。</p>
<p>4.方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">	el:<span class="string">"#app"</span>,</span></span><br><span class="line">	data:&#123; &#125;,</span><br><span class="line">	methods:&#123; </span><br><span class="line"><span class="actionscript">		add:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; </span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(<span class="string">"点我了...233"</span>)</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.生命周期,钩子函数</p>
<p>​        Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。</p>
<p>​        钩子函数不要使用箭头函数的方式编写。</p>
<p>​        具体有：beforeCreate，created,beforeMount,mounted,updated,beforeUpdate，destroyed，beforeDestroy</p>
<p>​        created钩子函数常用场景：用于初始化数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">""</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.msg=<span class="string">"hello,LY"</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        vue内部的<strong>this</strong>变量就是当前的Vue实例，在Vue对象内部，必须使用 this 才能访问到Vue中定义的data内属性、方法等。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h4 id="1-插值表达式"><a href="#1-插值表达式" class="headerlink" title="1.插值表达式"></a>1.插值表达式</h4><p>1.花括号</p>
<p>​        该表达式支持JS语法，可以调用js内置函数（<strong>必须有返回值</strong>） </p>
<p>　　表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1; </p>
<p>　　可以直接获取Vue实例中定义的数据或函数 </p>
<p>​        插值表达式不能用在标签的属性中。</p>
<p>2.插值闪烁</p>
<p>​        使用花括号方式在网速较慢时会出现问题。在数据未加载完成时，页面会显示出原始的花括号，加载完毕后才显示正确数据，称为插值闪烁。（最新vue是几乎没有此问题）</p>
<p>3.v-text和v-html</p>
<p>　　使用v-text和v-html指令来替代花括号</p>
<p>　　　v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出 </p>
<p>　　　v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染 </p>
<p>​        并且不会出现插值闪烁，当没有数据时，会显示空白。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg:<span class="string">""</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.msg=<span class="string">"hello,LY"</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-v-model"><a href="#2-v-model" class="headerlink" title="2.v-model"></a>2.v-model</h4><p>​        v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。</p>
<p>​        v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 </p>
<p>　　既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input ,select ,textarea ,checkbox ,radio ,components（Vue中的自定义组件）,基本上除了最后一项，其它都是表单的输入项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"java"</span> <span class="attr">v-model</span>=<span class="string">"language"</span>&gt;</span>java<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"PHP"</span> <span class="attr">v-model</span>=<span class="string">"language"</span>&gt;</span>PHP<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"C++"</span> <span class="attr">v-model</span>=<span class="string">"language"</span>&gt;</span>C++<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;language.join(",")&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            language:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　多个 checkbox 对应一个model时，model的类型是一个数组，单个checkbox值是boolean类型 </p>
<p>​        radio对应的值是input的value值 </p>
<p>​        input 和 textarea 默认对应的model是字符串 </p>
<p>​        select 单选对应字符串，多选对应也是数组</p>
<h4 id="3-v-on"><a href="#3-v-on" class="headerlink" title="3.v-on"></a>3.v-on</h4><p>　　用于给页面元素绑定事件。v-on:事件名=”js片段或函数名”或@事件名=”js片段或函数名” </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--直接写js片段--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"num++"</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用函数名，该函数必须要在vue实例中定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrement"</span>&gt;</span>减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">        num = &#123;&#123;num&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            num:1</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            decrement()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.num--;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>事件修饰符</strong></p>
<p>​            方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>　　　.stop ：阻止事件冒泡 </p>
<p>​                    .prevent ：阻止默认事件发生 </p>
<p>​                    .capture ：使用事件捕获模式 </p>
<p>​                    .self ：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） </p>
<p>　　　.once ：只执行一次 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    事件冒泡测试：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: lightblue;width: 100px;height: 100px"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"print('你点击了div')"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"print('点击了button')"</span>&gt;</span>点我试试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span>阻止默认事件：<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://shuitayangyang.github.io/"</span> @<span class="attr">click.prevent</span>=<span class="string">"print('点击超链接')"</span>&gt;</span>LT<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            print(msg)&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(msg)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-v-for"><a href="#4-v-for" class="headerlink" title="4.v-for"></a>4.v-for</h4><p>​        一般情况下，要遍历的数据可以通过钩子函数created发送异步请求获取数据。</p>
<p><strong>1.遍历数组</strong></p>
<p>​            遍历数据渲染页面,v-for=”item in items” </p>
<p>​                items：要遍历的数组，需要在vue的data中定义好。 </p>
<p>​                item：循环变量</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"user in users"</span>&gt;</span>&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.gender&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            users:[</span><br><span class="line"><span class="actionscript">                &#123;<span class="string">"name"</span>:<span class="string">"张三"</span>,<span class="string">"age"</span>:<span class="number">8</span>,<span class="string">"gender"</span>:<span class="string">"男"</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;<span class="string">"name"</span>:<span class="string">"李四"</span>,<span class="string">"age"</span>:<span class="number">12</span>,<span class="string">"gender"</span>:<span class="string">"女"</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;<span class="string">"name"</span>:<span class="string">"王五"</span>,<span class="string">"age"</span>:<span class="number">4</span>,<span class="string">"gender"</span>:<span class="string">"男"</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.数组角标</strong></p>
<p>​        在遍历的过程中，如果需要知道数组角标，可以指定第二个参数：v-for=”(item,index) in items” </p>
<p>　　　items：要迭代的数组 </p>
<p>　　　item：迭代得到的数组元素别名 </p>
<p>　　　index：迭代到的当前元素索引，从0开始。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(user,index) in users"</span>&gt;</span></span><br><span class="line">        	&#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.gender&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.遍历对象</strong></p>
<p>​        v-for=”value in object” ，得到的是对象的值</p>
<p>　　v-for=”(value,key) in object” ，第一个是值，第二个是键</p>
<p>​        v-for=”(value,key,index) in object” ，第三个是索引，从0开始</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in person"</span>&gt;</span> &#123;&#123;index&#125;&#125;--&#123;&#123;key&#125;&#125;--&#123;&#123;value&#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.key</strong></p>
<p>　　使用key这个功能可以有效的提高渲染的效率；key一般使用在遍历完后，又增、减集合元素的时候更有意义。为每项提供一个唯一 key 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-v-if和v-show"><a href="#5-v-if和v-show" class="headerlink" title="5.v-if和v-show"></a>5.v-if和v-show</h4><p><strong>1.v-if</strong></p>
<p>​        条件判断，当得到结果为true时，所在的元素才会被渲染。(v-if=”布尔表达式” )</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span> Hello VueJS. <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123; </span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            show:<span class="literal">true</span> </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.与v-for结合</strong></p>
<p>　　当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(user,index) in users"</span> <span class="attr">v-if</span>=<span class="string">"user.gender=='女'"</span>&gt;</span></span><br><span class="line">        &#123;&#123;index&#125;&#125;--&#123;&#123;user.name&#125;&#125;--&#123;&#123;user.age&#125;&#125;--&#123;&#123;user.gender&#125;&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.v-else</strong></p>
<p>​            v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p>
<p>​    v-else-if</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span> A <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span> B <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span> C <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span> Not A/B/C <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.v-show</strong></p>
<p>​        带有 v-show 的元素始终会被渲染并保留在 DOM 中。 v-show 只是简单地切换元素的 CSS 属性 display 。 </p>
<h4 id="6-v-bind"><a href="#6-v-bind" class="headerlink" title="6.v-bind"></a>6.v-bind</h4><p><strong>1.属性上使用vue数据</strong></p>
<p>​        v-bind:属性名=”Vue中的变量” </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"color"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 或 <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"color"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.class属性的特殊用法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"bool=!bool"</span>&gt;</span>点我改变下面色块颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123;red:bool,blue:!bool&#125;"</span>&gt;</span> 点击按钮改变背景颜色。 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        首先class绑定的是一个对象： {red:bool, blue: !bool} </p>
<p>​        red和blue这两个样式的生效标记恰好相反，一个生效，另一个失效。 </p>
<p>​        现在只需要一个按钮即可，点击时对bool取反，自然实现了样式的切换 </p>
<h4 id="7-计算属性"><a href="#7-计算属性" class="headerlink" title="7.计算属性"></a>7.计算属性</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>computed计算方式；你的生日为：&#123;&#123;birth&#125;&#125; <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            birthday:1429032123201</span><br><span class="line">        &#125;,</span><br><span class="line">        computed:&#123;</span><br><span class="line">            birth()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.birthday); </span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> date.getFullYear() + <span class="string">"-"</span> + (date.getMonth()+<span class="number">1</span>) + <span class="string">"-"</span> + date.getDay();</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。</p>
<h4 id="8-watch"><a href="#8-watch" class="headerlink" title="8.watch"></a>8.watch</h4><p><strong>1.监控</strong></p>
<p>　　监控一个值的变化。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123; </span><br><span class="line"><span class="actionscript">            message:<span class="string">"hello vue"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123; </span><br><span class="line">            message(newValue, oldValue)&#123; </span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"新值："</span> + newValue + <span class="string">"；旧值："</span> + oldValue); </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.深度监控</strong></p>
<p>​        如果监控的是一个对象，需要进行深度监控，才能监控到对象中属性的变化。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123; </span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123; </span><br><span class="line"><span class="actionscript">            person:&#123;<span class="string">"name"</span>:<span class="string">"itcast"</span>, <span class="string">"age"</span>:<span class="number">12</span>&#125; </span></span><br><span class="line">        &#125;,</span><br><span class="line">        watch:&#123; </span><br><span class="line">            person: &#123; </span><br><span class="line"><span class="actionscript">                <span class="comment">//开启深度监控，可以监控到对象属性值的变化 </span></span></span><br><span class="line"><span class="actionscript">                deep: <span class="literal">true</span>, </span></span><br><span class="line"><span class="actionscript">                <span class="comment">//监控的处理方法</span></span></span><br><span class="line">                handler(obj)&#123; </span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"name = "</span> + obj.name + <span class="string">", age="</span> + obj.age); </span></span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>　以前定义监控时，person是一个函数，现在改成了对象，并且要指定两个属性： </p>
<p>　　deep:代表深度监控，不仅监控person变化，也监控person中属性变化 </p>
<p>　　handler：就是以前的监控处理函数</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>　　把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。</p>
<h4 id="1-定义全局组件"><a href="#1-定义全局组件" class="headerlink" title="1.定义全局组件"></a>1.定义全局组件</h4><p>　　通过Vue的component方法来定义一个全局组件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">    <span class="comment">//定义组件 </span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> counter = &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: "<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'num++'</span>&gt;</span>你点击了</span><span class="template-variable">&#123;&#123;num&#125;&#125;</span><span class="xml">次；我记住了<span class="tag">&lt;/<span class="name">button</span>&gt;</span>", </span></span></span><br><span class="line">        data()&#123; </span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;num: <span class="number">0</span>&#125; </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="comment">//全局注册组件；参数1：组件名称，参数2：组件 </span></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"counter"</span>, counter); </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123; </span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span> </span></span><br><span class="line">    &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 </p>
<p>　　不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 </p>
<p>　　但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 </p>
<p>　　全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 </p>
<p>　　data的定义方式比较特殊，必须是一个函数。</p>
<h4 id="2-组件的复用"><a href="#2-组件的复用" class="headerlink" title="2. 组件的复用"></a>2. 组件的复用</h4><p>　　定义好的组件，可以任意复用多次。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--使用定义好的全局组件--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　每个组件互不干扰，都有自己的num值。</p>
<p>​        一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝</p>
<h4 id="3-局部注册"><a href="#3-局部注册" class="headerlink" title="3.局部注册"></a>3.局部注册</h4><p>​        一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。对于一些并不频繁使用的组件，会采用局部注册。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var app = new Vue(&#123; </span><br><span class="line">	el:"#app", </span><br><span class="line">	//局部注册组件</span><br><span class="line">	components:&#123; </span><br><span class="line">		counter: counter </span><br><span class="line">	&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​        components就是当前vue对象子组件集合。 </p>
<p>　　　其key就是子组件名称 </p>
<p>　　　其值就是组件对象的属性 </p>
<p>​        效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用</p>
<h4 id="4-组件通信"><a href="#4-组件通信" class="headerlink" title="4.组件通信"></a>4.组件通信</h4><p>​        通常一个单页应用会以一棵嵌套的组件树的形式来组织：</p>
<p>　　　页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 </p>
<p>　　　左侧内容区又分为上下两个组件 </p>
<p>　　　右侧边栏中又包含了3个子组件 </p>
<p>　　各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 </p>
<p><strong>1.父向子传递props</strong></p>
<p>　　父组件使用子组件，同时传递title属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用定义好的全局组件--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">introduce</span> <span class="attr">:title</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">introduce</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">    <span class="comment">//定义组件 </span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> introduce = &#123; </span></span><br><span class="line"><span class="actionscript">        <span class="comment">//使用props属性title的值渲染模版 </span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: "<span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><span class="template-variable">&#123;&#123;title&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span>", </span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//定义接收来自父组件的属性 </span></span></span><br><span class="line"><span class="actionscript">        props:[<span class="string">"title"</span>] &#125;;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//全局注册组件；参数1：组件名称，参数2：组件 </span></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"introduce"</span>, introduce); </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123; </span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>, </span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            msg: <span class="string">"父组件中的msg属性的内容"</span></span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.传递复杂数据</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>面向对象<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 接受来自父组件的属性值，使用v-bind指向父组件的属性lessons；注意使用my-list --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-list</span> <span class="attr">:items</span>=<span class="string">"lessons"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-list</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">    <span class="comment">//定义组件</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> myList = &#123; </span></span><br><span class="line"><span class="actionscript">        <span class="comment">//可以使用双引号、单引号或者如下使用的 ` 飘号 </span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: ` <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.id&#125;&#125;</span><span class="xml">--</span><span class="template-variable">&#123;&#123;item.name&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> `,</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//定义接收来自父组件的属性 </span></span></span><br><span class="line">        props: &#123; </span><br><span class="line"><span class="actionscript">            <span class="comment">//定义模版中使用的属性 </span></span></span><br><span class="line">            items: &#123; </span><br><span class="line"><span class="actionscript">                <span class="comment">//必须为数组类型 </span></span></span><br><span class="line"><span class="javascript">                type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//默认为空数组 </span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">default</span>: [] </span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123; </span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>, </span></span><br><span class="line">        data: &#123; </span><br><span class="line">           lessons:[</span><br><span class="line"><span class="actionscript">               &#123;<span class="string">"id"</span>:<span class="number">1</span>, <span class="string">"name"</span>:<span class="string">"继承"</span>&#125;, </span></span><br><span class="line"><span class="actionscript">               &#123;<span class="string">"id"</span>:<span class="number">2</span>, <span class="string">"name"</span>:<span class="string">"封装"</span>&#125;, </span></span><br><span class="line"><span class="actionscript">               &#123;<span class="string">"id"</span>:<span class="number">3</span>, <span class="string">"name"</span>:<span class="string">"多态"</span>&#125; </span></span><br><span class="line">           ] </span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="comment">//注册组件 </span></span></span><br><span class="line">        components: &#123; </span><br><span class="line"><span class="actionscript">            <span class="comment">//如果组件key和value一致可以简写如下</span></span></span><br><span class="line">            myList </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>　　这个子组件可以对 items 进行迭代，并输出到页面。 </p>
<p>　　但是组件中并未定义items属性。 </p>
<p>　　通过props来定义需要从父组件中接收的属性</p>
<p>　　　items：是要接收的属性名称 </p>
<p>　　　　type：限定父组件传递来的必须是数组，否则报错；type的值可以是Array或者Object（传递对象的时候使用） </p>
<p>　　　　default：默认值， </p>
<p>　　　　default，如果是对象则需要写成方法的方式返回默认值。如： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default()&#123; </span><br><span class="line">	return &#123;&quot;xxx&quot;:&quot;默认值&quot;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.子向父的通信</strong></p>
<p>　　子组件不能直接修改父组件传递参数的引用或者基本类型参数值。</p>
<p>　　vue提供了一个内置的this.$emit函数，用来调用父组件绑定的函数</p>
<p>　　通过v-on指令将父组件的函数绑定到子组件上，然后，当子组件中按钮被点击时，调用绑定的函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>num = &#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--使用定义好的全局组件--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> @<span class="attr">plus</span>=<span class="string">"numPlus"</span> @<span class="attr">reduce</span>=<span class="string">"numReduce"</span> <span class="attr">:snum</span>=<span class="string">"num"</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">    <span class="comment">//定义组件 </span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> counter = &#123; </span></span><br><span class="line"><span class="actionscript">        <span class="comment">//组件只能是一个元素里面包裹其他元素；如下面，一个div包含两个按钮 </span></span></span><br><span class="line">        template: </span><br><span class="line"><span class="handlebars"><span class="xml">        ` <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"incrNum"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span></span><br><span class="line"><span class="handlebars"><span class="xml">			<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrNum"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> 			</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    	 <span class="tag">&lt;/<span class="name">div</span>&gt;</span> `,</span></span></span><br><span class="line"><span class="actionscript">        props:[<span class="string">"snum"</span>], </span></span><br><span class="line">        methods: &#123; </span><br><span class="line"><span class="actionscript">            <span class="comment">//点击模板中使用的方法 </span></span></span><br><span class="line">            incrNum()&#123; </span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.$emit(<span class="string">"plus"</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            decrNum()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.$emit(<span class="string">"reduce"</span>); </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="comment">//全局注册组件；参数1：组件名称，参数2：组件 </span></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"counter"</span>, counter); </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123; </span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>, </span></span><br><span class="line">        data:&#123;</span><br><span class="line">            num:0 </span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123; </span><br><span class="line"><span class="actionscript">            <span class="comment">//父组件中定义操作num的方法 </span></span></span><br><span class="line">            numPlus()&#123; </span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.num++; </span></span><br><span class="line">            &#125;,</span><br><span class="line">            numReduce()&#123; </span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.num--; </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>​        Vuejs 并没有直接处理ajax的组件，但可以使用axios或vue-resource组件实现对异步请求的操作。</p>
<h4 id="1-vue-resource"><a href="#1-vue-resource" class="headerlink" title="1.vue-resource"></a>1.vue-resource</h4><p>　　vue-resource是Vue.js的插件提供了使用XMLHttpRequest或JSONP进行Web请求和处理响应的服务。 当vue更新到2.0之后，作者就宣告不再对vue-resource更新，而是推荐axios。</p>
<h4 id="2-axios"><a href="#2-axios" class="headerlink" title="2.axios"></a>2.axios</h4><p>​        Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<p>　　　#如果使用npm则可以如下安装</p>
<p>​                 npm install axios</p>
<p>​        或者也可以直接使用公共的CDN（内容分发网络）服务：</p>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script> 

<h4 id="3-axios应用"><a href="#3-axios应用" class="headerlink" title="3.axios应用"></a>3.axios应用</h4><p><strong>1.方法说明</strong></p>
<p>​        axios可以使用的方法有： </p>
<p>　　　axios(confifig) </p>
<p>　　　axios.get(url[, confifig]) </p>
<p>​                axios.delete(url[, confifig]) </p>
<p>　　　axios.head(url[, confifig]) </p>
<p>​                axios.post(url[, data[, confifig]]) </p>
<p>​                axios.put(url[, data[, confifig]]) </p>
<p>​                axios.patch(url[, data[, confifig]]) </p>
]]></content>
  </entry>
  <entry>
    <title>技术总结</title>
    <url>/2020/04/04/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>学习技术5步走：</p>
<p>   a.概念   是什么 ， 能干啥 ， 有啥用</p>
<p>   b.  为啥要用？  有啥 优势</p>
<p>   c. 流程+原理  （面试最重要的点）  底层代码 </p>
<p>   d.如果使用  核心api（会不会用方法 ，注解）</p>
<p>   e.和项目结合 。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>​    1.关系型数据库,默认使用可重复读</p>
<p>​    2.事务四大特性:原子性,一致性,隔离性,持久性</p>
<p>​    3.索引:</p>
<p>​        B+Tree，不用扫描整张表得到需要的数据，从根节点开始，存储引擎会根据指针快速寻找数据。</p>
<p>​        index—-普通索引，unique—- 唯一索引，primary key —- 主键索引，组合索引，全文索引</p>
<p>​    4.存储引擎 MyISAM 和 InnoDB</p>
<p>​        InnoDB支持事务，MyISAM不支持。</p>
<p>​        InnoDB支持外键，MyISAM不支持。</p>
<p>​        InnoDB是默认引擎</p>
<p>​        现在一般都选用InnoDB，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于    读写密集型应用一般是不会去选用的。</p>
<p>​    5.delete、drop、truncate</p>
<p>​        当你不再需要该表时，用 drop;</p>
<p>​        当你仍要保留该表，但要删除所有记录时，用 truncate;</p>
<p>​        当你要删除部分记录时, 用 delete.</p>
<p>​        注意： 对于有主外键关系的表，不能使用truncate而应该使用不带where子句的delete语句，由于truncate不记录在日志中，不能够激活触发器</p>
<p>​    6.分布式ID生成器</p>
<p>​        雪花算法生成唯一主键值</p>
<p>​        分库分表是不要使用自带的自增,会有可能不同文章生成同样的id,使用分布式ID生成器</p>
<h2 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h2><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>​    1.客户端和服务器端之间数据传输的格式规范,请求-响应协议,无状态协议(指协议对于事务处理没有记忆能力),解决办法：1、Cookie 2、通过Session会话保存。无连接(限制每次连接只处理一个请求)</p>
<p>​    2.常见Http协议状态:</p>
<p>​        200：请求被正常处理</p>
<p>​        301：永久性重定向</p>
<p>​        400：请求报文语法有误，服务器无法识别</p>
<p>​        403：请求的对应资源禁止被访问</p>
<p>​        404：服务器无法找到对应资源</p>
<p>​        500：服务器内部错误</p>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>​    1.脚本语言(不需要编译),用于增强HTML页面,以交互式和动态的方式呈现网页</p>
<p>​    2.跨平台,不依赖于操作系统,仅需要浏览器的支持。</p>
<p>​    3.DOM处理网页内容,BOM与浏览器交互</p>
<h4 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h4><p>​    1.是一个简洁而快速的JavaScript库,</p>
<p>​    2.方便获取DOM元素</p>
<p>​    3.统一Ajax操作</p>
<h4 id="Echars"><a href="#Echars" class="headerlink" title="Echars"></a>Echars</h4><p>​    1.商业级数据图表，它是一个纯JavaScript的图标库</p>
<h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><p>​    1.构建用户界面的渐进式框架,核心是双向数据绑定,组件化</p>
<p>​    2.MVVM设计模式即model，view，viewmodel，它是数据驱动模式，即所有的一切通过操作数据来进行，而尽量避免操作dom树。</p>
<p><img src="/2020/04/04/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%5Cvue.png" alt></p>
<p>​    3.axios异步</p>
<h4 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h4><p>​    1.基于Vue2.0开发,提供了丰富的PC端组件</p>
<h4 id="NUXT"><a href="#NUXT" class="headerlink" title="NUXT"></a>NUXT</h4><p>​    1.前端页面渲染</p>
<h4 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h4><p>​    1.是一个使用 <code>Vue.js</code> 开发跨平台应用的前端框架,开发者编写一套代码,可编译到<code>iOS</code>、<code>Android</code>、<code>H5</code>、小程序等多个平台。</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>​    在客户端保存,保存用户名密码</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>​    在服务端保存</p>
<p>​    session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）</p>
<h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>介绍</p>
<p>​    负责处理客户请求,把结果返回给客户。交互式的浏览和生成数据,生成动态web内容,必须实现Servlet接口,用来处理网络请求的一套规范.</p>
<p>生命周期</p>
<p>​    1.收到请求后检查是否存在后创建Servlet实例对象</p>
<p>​    2.调用Servlet对象的init()</p>
<p>​    3.调用service()将请求(HttpServletRequest)和响应(HttpServletResponse)对象作为参数传递进去</p>
<p>​    4.WEB应用程序被停止或重新启动之前，调用destroy()</p>
<p>forward()与redirect()区别?</p>
<p>​    forward():转发,一次请求,共享request数据,服务器行为,地址栏不变</p>
<p>​    redirect():重定向,两次请求,不能共享数据,客户端行为,地址栏改变</p>
<h4 id="JSP-Java-Server-Pages"><a href="#JSP-Java-Server-Pages" class="headerlink" title="JSP(Java Server Pages)"></a><strong>JSP</strong>(Java Server Pages)</h4><p>​    动态网页技术标准,部署于服务器,响应客户端发送的请求,根据请求动态的生成web网页,实现以静态页面为模板动态生成其中部分内容,是Servlet技术的扩展,HTML+Java片段</p>
<p>​    处理 JSON，通常需要配套使用 JQuery 控件</p>
<p>​    和Servlet相比,Jsp的可读性强，容易看得懂</p>
<p>​    有九个内置对象：request、response、out、session、application、pageContext、config、page、exception</p>
<h4 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h4><p>​    它提供了在 JSP 中简化表达式的方法</p>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>​    使网页实现异步更新。</p>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>​    过滤器,</p>
<h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>​    监听器,</p>
<h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>​    分布式版本控制系统,一般工作流程如下：</p>
<p>​    1、git clone 克隆远程资源到本地目录，作为工作目录；</p>
<p>​    2、然后在本地的克隆目录上添加或修改文件；</p>
<p>​    3、如果远程修改了，需要同步远程的内容，直接git pull就可以更新本地的文件；</p>
<p>​    4、本地在修改之后，可以通过git status 查看修改的文件。然后使用git add 添加修改的文件暂到缓冲区；</p>
<p>​    5、在添加之后，可以使用git commit添加到当前的工作区；</p>
<p>​    6、在修改完成后，如果发现错误，可以撤回提交并再次修改并提交；</p>
<p>​    7、git push将本地的修改推送到远程的git服务器。</p>
<h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><p>​    主要服务于基于Java平台的项目构建、依赖管理和项目信息管理，为了不重复造轮子。</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>​    反射是框架设计的灵魂</p>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p>​    1.用Spring来创建对象,整合其他框架,通过反射创建对象</p>
<p>​    2.IOC控制反转,直接在spring容器中拿对象,DI依赖注入（将对象之间的依赖关系交由框架处理，减低组件的耦合性），构造器注入、setter方法注入、根据注解注入</p>
<p>​    3.AOP动态代理,接口jdk,继承cglib,实现程序功能的统一维护,事务管理（配置文件中添加事务管理器和开启注解,@Transaction）,日志</p>
<h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><p>​    1.和 Spring 其他框架无缝集成,是一个实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦</p>
<p>​    2.SpringMVC的流程:</p>
<p>​    （1）用户发送请求至前端控制器DispatcherServlet；    </p>
<p>​    （2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；</p>
<p>​    （3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给              DispatcherServlet；</p>
<p>​    （4）DispatcherServlet 调用 HandlerAdapter处理器适配器；</p>
<p>​    （5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；</p>
<p>​    （6）Handler执行完成返回ModelAndView；</p>
<p>​    （7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</p>
<p>​    （8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</p>
<p>​    （9）ViewResolver解析后返回具体View；</p>
<p>​    （10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</p>
<p>​    （11）DispatcherServlet响应用户。</p>
<p>​    3.SpringMvc和AJAX相互调用:通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。</p>
<p>​    4.POST请求中文乱码:在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8</p>
<p>​    5.GET请求中文乱码:修改tomcat配置文件添加编码与工程编码一致</p>
<p>​    6.异常处理:抛给Spring框架</p>
<p>​    7.常用的注解:</p>
<p>​        @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>​        @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p>​        @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<h4 id="MVC开发模式"><a href="#MVC开发模式" class="headerlink" title="MVC开发模式"></a>MVC开发模式</h4><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><p>​    1.持久层框架</p>
<p>​    2.sql写在xml,统一管理,优化</p>
<p>​    3.使用:依赖,application.yml配置,SpringBoot启动类包扫描,dao继承BaseMapper</p>
<p>Mybatis-Plus</p>
<p>​    1.性能损耗小：启动即会自动注入基本CURD ，性能无损耗，直接面向对象操作 </p>
<p>​    2.自动热加载：Mapper对应的xml可以热加载，大大减少重启Web服务器时间，提升开发效率 </p>
<p>​    3.性能分析：自带Sql性能分析插件，开发测试时，能有效解决慢查询 </p>
<p>​    4.全局拦截：提供全表delete、update操作智能分析阻断 </p>
<p>​    5.避免Sql注入：内置Sql注入内容剥离器，预防Sql注入攻击 </p>
<p>​    6.与Mybatis的不同,依赖,配置文件</p>
<h4 id="Spring-data-jpa"><a href="#Spring-data-jpa" class="headerlink" title="Spring data jpa"></a>Spring data jpa</h4><p>​    1.用于表的基本CRUD。</p>
<h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>​    1.简化了spring的开发过程,开箱即用,远离繁琐的配置。</p>
<p>​    2.application.yml配置文件:服务名,数据库连接,端口号</p>
<p>​    3.@SpringBootApplication启动类</p>
<h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><p>​    1.微服务框架的规范</p>
<p>​    2.功能:服务注册与发现,负载均衡,服务熔断与限流,智能路由,控制总线,链路监控</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>​    CAP:分布式系统中,一致性(c),可用性(a),分区容错性(p),p是必须保证的</p>
<h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><p>​    1.服务注册与发现,AP原则</p>
<p>​    2.两大组件:Eureka Server,Eureka client</p>
<p>​    3.应用启动后向Server发送心跳,周期三十秒,90秒没收到会移除服务节点,自我保护:为网络异常时保持高可用设计的,不会注销服务实例,直至心跳恢复</p>
<p>​    5.集群:Eureka Server启动时默认注册自己,配置多个相互注册,高并发,高可用</p>
<p>​    6.可以很好地应对因为网络故障导致部分节点失去连接的情况,不会像Zookeeper那样导致整个注册服务系统的瘫痪</p>
<h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p>​    1.RPC框架</p>
<p>​    2.服务方与消费方远程调用，将核心业务抽取出来，作为独立的服务,分布式</p>
<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><p>​    1.注册中心</p>
<h4 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h4><p>​    1.网关,用户认证</p>
<p>​    2.业务流程说明如下：</p>
<p>​        1、客户端请求认证服务进行认证。</p>
<p>​        2、认证服务认证通过向浏览器cookie写入token(身份令牌)</p>
<p>​            认证服务请求用户中心查询用户信息。</p>
<p>​            认证服务请求Spring Security申请令牌。</p>
<p>​            认证服务将token(身份令牌)和jwt令牌存储至redis中。</p>
<p>​            认证服务向cookie写入 token(身份令牌)。</p>
<p>​        3、前端携带token请求认证服务获取jwt令牌****</p>
<p>​            前端获取到jwt令牌并存储在sessionStorage。</p>
<p>​            前端从jwt令牌中解析中用户信息并显示在页面。</p>
<p>​        4、前端携带cookie中的token身份令牌及jwt令牌访问资源服务</p>
<p>​            前端请求资源服务需要携带两个token，一个是cookie中的身份令牌，一个是http header中的jwt令牌</p>
<p>​            前端请求资源服务前在http header上添加jwt请求资源</p>
<p>​        5、网关校验token的合法性</p>
<p>​            用户请求必须携带token身份令牌和jwt令牌</p>
<p>​            网关校验redis中token是否合法，已过期则要求用户重新登录</p>
<p>​        6、资源服务校验jwt的合法性并完成授权</p>
<p>​            资源服务校验jwt令牌，完成授权，拥有权限的方法正常执行，没有权限的方法将拒绝访问。</p>
<h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><p>​    1.安全认证服务框架,原理就是在访问我们的系统前加了一系列的过滤器</p>
<h4 id="Oauth2"><a href="#Oauth2" class="headerlink" title="Oauth2"></a>Oauth2</h4><p>​    1.客户应用向授权服务器请求令牌与授权服务器颁发令牌的过程标准化,OAuth2会提供授权请求，访问令牌和刷新令牌</p>
<p>​    2.应用场景:</p>
<p>​        第三方应用授权登录：在APP或者网页接入一些第三方应用时，时长会需要用户登录另一个合作平台，比如 QQ，微博，微信的授权登录。</p>
<p>​        原生app授权：app登录请求后台接口，为了安全认证，所有请求都带token信息，如果登录验证、请求后台数据。</p>
<p>​        前后端分离单页面应用（spa）：前后端分离框架，前端请求后台数据，需要进行oauth2安全认证，比如使用vue、react后者h5开发的app。</p>
<h4 id="Gateway-网关"><a href="#Gateway-网关" class="headerlink" title="Gateway(网关)"></a>Gateway(网关)</h4><p>​    1.路由,过滤器()核心功能</p>
<p>​    2.加在整个微服务最前沿的防火墙和代理器,隐藏微服务IP端口信息,从而加强保护,本身也是一个微服务,需要注册到Eureka服务注册中心</p>
<p>​    3.实现请求的鉴权,IP黑白名单,特定地址拦截</p>
<h4 id="Hystrix-熔断器"><a href="#Hystrix-熔断器" class="headerlink" title="Hystrix(熔断器)"></a>Hystrix(熔断器)</h4><p>​    业务复杂访问量高的时候用的多,</p>
<h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h4><p>​    1.轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p>
<h2 id="服务器中间件"><a href="#服务器中间件" class="headerlink" title="服务器中间件"></a>服务器中间件</h2><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>​    1.消息中间件</p>
<p>​    2.不需要同步且耗时长的操作</p>
<p>​    3.生产与消费通过MQ,解耦</p>
<p>​    4.Spring Boot默认集成</p>
<p>​    5.工作模式:简单,工作队列,发布订阅,路由,通配符</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>​    1.存放高热点,经常查询的数据,经常修改或财务数据不放这里,支持事务</p>
<p>​    2.自身是Map,数据key:value格式</p>
<p>​    3.数据类型:String,Hash,List,Set,zset(有序集合)</p>
<p>​    4.持久化:把内存的数据写到硬盘中,RDB(默认,性能好),AOF(安全)</p>
<p>​    5.架构:单机,主从复制,哨兵,集群</p>
<h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>​    1.分布式文件存储的数据库,非关系型数据库,存储Json格式数据 ,数据格式灵活。</p>
<p>​    2.最终一致性，更能保证用户的访问速度</p>
<p>​    3.文档结构的存储方式，能够更便捷的获取数据</p>
<p>​    4.不支持事务操作,磁盘空间占用比较大</p>
<p>​    5.内置GridFS,分布式文件系统，可以支持海量的数据存储。</p>
<h2 id="服务器技术"><a href="#服务器技术" class="headerlink" title="服务器技术"></a>服务器技术</h2><h4 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h4><p>​    1.用户通过浏览器向web服务器发送http请求,web服务器解析http请求将请求路径的文件返回给浏览器,浏览器再将文件渲染显示给我们看，因此web服务器的作用就是返回服务端的静态文件。</p>
<h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><p>​    1.是servlet容器,是web服务器</p>
<p>​    2.在传统的Web项目中，并发量小，用户使用的少。所以在低并发的情况下，用户可以直接访问tomcat服务器，然后tomcat服务器返回消息给用户。</p>
<p>​    3.应用场景:</p>
<pre><code>1、 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。</code></pre><p>​      2、 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</p>
<ul>
<li>基于端口的，不同的端口</li>
<li>基于域名的，不同域名</li>
</ul>
<p>​      3、 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>​    1.是性能非常好的反向代理服务器，用来做负载均衡。隐藏真实服务端</p>
<p>​    2.异步,减轻后端Web服务器的压力</p>
<p>​    3.多进程机制,好处是各个进程之间相互独立，不需要加锁，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。</p>
<h4 id="Linx"><a href="#Linx" class="headerlink" title="Linx"></a>Linx</h4><p>​    1.查看进程:ps-ef|grep</p>
<p>​    2.查看端口:netstat -anp|grep</p>
<p>​    3.压缩:tar -czf</p>
<p>​    4.解压:tar -xvzf</p>
<h4 id="Vmware"><a href="#Vmware" class="headerlink" title="Vmware"></a>Vmware</h4><p>​    1.虚拟机,</p>
<h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><p>​    1.是 Linux操作系统品牌</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>​    1.Docker的思想来自于集装箱,可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>​    2.Web 应用的自动化打包和发布。自动化测试和持续集成、发布。</p>
<p>​    3.更快速的交付和部署,高效的部署和扩容,更高的资源利用率,更简单的管理</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h4 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h4><p>​    1.接口测试</p>
<p>​    2.与Nginx整合开发接口文档</p>
<h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>​    1.http接口测试工具</p>
<p>​    2.能够发送任何类型的HTTP 请求 (GET，HEAD， POST，PUT。。。) </p>
<p>​    3.附带任意数量的参数</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>​    1.分布式全文检索引擎</p>
<p>​    2.Lucene为核心,简化操作</p>
<p>​    3.使用logstash采集数据,同步索引库,删除信息无法使用logstash,在service方法删除课程信息时将索引库中的也删除</p>
<p>​    4.数据分散,汇总到一张表来让logstash采集数据,部署集群</p>
<p><img src="/2020/04/04/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%5CElasticsearch.png" alt></p>
<h4 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h4><p>​    1.模板引擎,模板+数据</p>
<p>​    2.模板:好说,提前编写出来;数据:编辑页面信息时定义一个dataUrl(例:由开发轮播图管理的程序员提供),读页面信息远程请求http地址,拿到数据</p>
<p>​    3.过程:1.静态化程序读取页面信息拿到dataUrl,2.远程请求获取数据模型,3.获取页面模板,MongoDB的分布式文件系统GridFS,4.通过FreeMarker的API生成静态化文件</p>
<h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>​    1.客户端负载均衡</p>
<p>​    2.ribbon 负责获取注册中心的远程服务信息以及提供负载均衡功能</p>
<h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><p>​    1.轻量级rest客户端,就像restTemplate 的简化,Web Service客户端</p>
<p>​    2.</p>
<h4 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h4><p>​    1.配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。</p>
<h4 id="RESTful架构风格"><a href="#RESTful架构风格" class="headerlink" title="RESTful架构风格"></a>RESTful架构风格</h4><p>​    1.7个HTTP方法：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS</p>
<p>​    2.网络通信规范,rest风格是用来描述接口的,http 接口按照rest风格设计就是 restfull http</p>
<p>​    3.幂等性：不论你请求多少次，资源的状态是一样的。</p>
<p>​    4.常见请求返回响应码:</p>
<p>​        200,请求成功</p>
<p>​        400,客户端请求的语法错误，服务器无法理解(例:接口接受数字,请求发送的中文)</p>
<p>​        404,资源没找到</p>
<p>​        500,服务器内部错误，无法完成请求 ,逻辑,代码等错误</p>
]]></content>
  </entry>
</search>
